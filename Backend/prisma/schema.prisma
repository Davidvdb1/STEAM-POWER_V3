generator client {
  provider      = "prisma-client-js"
  binaryTargets = ["native", "debian-openssl-3.0.x"]
}

datasource db {
  provider = "postgresql"
  url      = env("DATABASE_URL")
}

enum Role {
  ADMIN
  TEACHER
}

enum EnergyType {
  SOLAR
  WATER
  WIND
}

model User {
  id       String @id @default(uuid())
  username String
  email    String @unique
  password String
  role     Role
}

model Camp {
  id        String     @id @default(uuid())
  name      String
  startDate DateTime
  endDate   DateTime
  startTime String
  endTime   String
  minAge    Int
  maxAge    Int
  picture   String
  archived  Boolean    @default(false)
  address   String
  workshops Workshop[]
}

model Workshop {
  id       String  @id @default(uuid())
  html     String
  title    String
  campId   String?
  archived Boolean @default(false)
  position Int

  camp Camp? @relation(fields: [campId], references: [id])
}

model Group {
  id               String           @id @default(uuid())
  name             String           @unique
  members          String           @default("")
  microbitId       String           @default("")
  code             String           @unique @default(dbgenerated("substring(md5(random()::text), 1, 6)"))
  energy           Float            @default(0)
  energyMultiplier Float            @default(1)
  batteryLevel     Float            @default(0)
  batteryCapacity  Float            @default(500)
  energyData       EnergyData[]
  bonusScore       Int              @default(0)
  answers          Answer[]

  // back-relation to GameStatistics aggregate
  gameStatistics   GameStatistics[]
}

model EnergyData {
  id      String     @id @default(uuid())
  groupId String
  time    DateTime   @default(now())
  type    EnergyType
  value   Int
  pin     Int

  group Group @relation(fields: [groupId], references: [id])
}

model Question {
  id                String     @id @default(uuid())
  title             String
  description       String
  questionStatement String
  energyType        EnergyType
  picture           String
  maxTries          Int        @default(0)
  wattage           Int
  score             Int
  active            Boolean    @default(true)
  answers           Answer[]
  errorMargin       Float      @default(0.5)
}

model Answer {
  id            String   @id @default(uuid())
  groupId       String
  questionId    String
  isCorrect     Boolean
  answerValue   Float
  energyReading Float
  errorMargin   Float    @default(0)

  group    Group    @relation(fields: [groupId], references: [id])
  question Question @relation(fields: [questionId], references: [id])
}

model Currency {
  id          String            @id @default(uuid())
  greenEnergy Float
  greyEnergy  Float
  coins       Float

  // back-relations only; FKs defined on the other side
  gameStatistics GameStatistics? @relation("GS_Currency")
  checkpoint     Checkpoint?     @relation("CP_Currency")
}

model Level {
  id           String     @id @default(uuid())
  level        Int
  upgradeCost  Int
  energyCost   Int

  buildings    Building[]
}

model Asset {
  id               String           @id @default(uuid())
  buildCost        Int
  destroyCost      Int
  energy           Float
  xLocation        Int
  yLocation        Int
  xSize            Int
  ySize            Int

  // belongs to a snapshot
  checkpoint       Checkpoint?      @relation(fields: [checkpointId], references: [id])
  checkpointId     String?

  // belongs to the live aggregate
  gameStatistics   GameStatistics?  @relation(fields: [gameStatisticsId], references: [id])
  gameStatisticsId String?
}

model Building {
  id               String           @id @default(uuid())
  xLocation        Int
  yLocation        Int
  xSize            Int
  ySize            Int

  level            Level            @relation(fields: [levelId], references: [id])
  levelId          String

  // live aggregate relation
  gameStatistics   GameStatistics?  @relation(fields: [gameStatisticsId], references: [id])
  gameStatisticsId String?

  // back-relation for snapshot in Checkpoint
  checkpoint       Checkpoint?      @relation("CP_Building")
}

model Checkpoint {
  id               String           @id @default(uuid())

  // one-to-one snapshot of Currency
  currencies       Currency         @relation("CP_Currency", fields: [currenciesId], references: [id])
  currenciesId     String           @unique

  // one-to-one snapshot of Building
  building         Building         @relation("CP_Building", fields: [buildingId], references: [id])
  buildingId       String           @unique

  // snapshot of Assets
  assets           Asset[]

  // belongs to the live aggregate
  gameStatistics   GameStatistics?  @relation(fields: [gameStatisticsId], references: [id])
  gameStatisticsId String?
}

model GameStatistics {
  id               String           @id @default(uuid())

  // the “current” Currency
  currencies       Currency         @relation("GS_Currency", fields: [currenciesId], references: [id])
  currenciesId     String           @unique

  // ties back to an existing Group
  group            Group            @relation(fields: [groupId], references: [id])
  groupId          String

  // live Buildings, Checkpoints, Assets
  building         Building[]
  checkpoint       Checkpoint[]
  assets           Asset[]
}
